% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_lasso.R
\name{grid_lasso}
\alias{grid_lasso}
\title{Computes solution paths for continuous response model}
\usage{
grid_lasso(
  x = NULL,
  y,
  XtX = NULL,
  Xty = NULL,
  standardize = TRUE,
  var_order = NULL,
  lambda = NULL,
  nlambda = 100L,
  lambda.min.ratio = ifelse(n < p, 0.01, 1e-04),
  grid.size = p,
  thresh = 1e-10,
  maxit = 1e+05,
  return.list = TRUE,
  sparse = TRUE,
  grid.size.truncate = grid.size,
  early.stopping = TRUE,
  early.stopping.factor = 0.5,
  missing.data = F,
  psd.method = "enet",
  enet.scale = F
)
}
\arguments{
\item{x}{Design matrix, n x p}

\item{y}{Vector of responses, length n}

\item{XtX}{User-specified (scaled and centred) gram matrix if this is known to avoid its recomputation each time}

\item{Xty}{User-specified (scaled and centred) t(X) times y / n, if this is know to avoid its recomputation each time}

\item{standardize}{Scales design matrix before computation. Setting FALSE recommended for advanced use only}

\item{var_order}{For user-specified ordering of variables. Indices start at 0, start with least important variable and end with most. By default order will be induced from scaling of columns in design matrix}

\item{lambda}{For user-specified sequence of tuning parameter lambda}

\item{nlambda}{Length of automatically generated sequence of tuning parameters lambda}

\item{lambda.min.ratio}{Ratio of max/min lambda for automatically generated sequence of tuning parameters lambda}

\item{grid.size}{Number of subsets of variables for which a solution path will be computed for}

\item{thresh}{Convergence threshold for coordinate descent for difference in objective values between successive iterations}

\item{maxit}{Maximum number of iterations for coordinate descent routine}

\item{return.list}{Returns all solution paths as a list. If set to false this is returned as one large concatenated vector. FALSE should only be used when one is interested in running speed tests}

\item{sparse}{Whether to use sparse matrices in computation (setting FALSE recommended for advanced users only)}

\item{grid.size.truncate}{Not for user modification and is only altered when called from cv_grid_lasso}

\item{early.stopping}{Whether square-root lasso condition for early stopping along lambda path should be used}

\item{early.stopping.factor}{Factor of correction in square-root lasso early stopping criterion}

\item{missing.data}{If TRUE then will use (slower) procedure that corrects for missing data}

\item{psd.method}{The way that the gram matrix is made positive semidefinite. By default an elastic net term, alternatives are "coco" for CoCoLasso}

\item{enet.scale}{Experimental and to be removed}
}
\value{
A list of objects:
\itemize{
\item mu -- estimated intercept
\item beta -- a list of matrices, one for each subset of variables in the grid. Each matrix contains a full solution path
\item lambda -- Vector of values of lambda used
\item col.means -- vector of column means in unstandardized design matrix; important for making predictions on new data.
}
}
\description{
Computes solutions for grid lasso method
}
\examples{
set.seed(1)
X = matrix(0, 50, 500)
Z = matrix(0, 10, 500)
betavec = c(rep(1,5),rep(0,495))
X[ , 1:5 ] = matrix(rnorm(250), 50, 5)
Z[ , 1:5 ] = matrix(rnorm(50), 10, 5)
Y = X \%*\% betavec
Y = Y + rnorm(50)
X = X + matrix(rnorm(50*500), 50, 500)
mod1 = grid_lasso(X, Y, grid.size = 50)
predict(mod1, Z, 45, 80)

}
